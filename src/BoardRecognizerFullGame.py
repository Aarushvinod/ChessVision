import cv2
import numpy as np
from ultralytics import YOLO
import chess
import chess.svg
from tabulate import tabulate
from src.Square import Square
import torch.cuda as GPU

#Primary class holding Board Recognition Logic for Full Games from Starting Position
#It is also equipped to handle Chess960

class BoardRecognizerFullGame:

    def __init__(self, pieces_name: str):
        #The class has 3 fields
        # 1. The piece detection model
        # 2. The target image on which all computations are run
        # 3. The homography matrix which will be used for the whole game
        self.piece_detector: YOLO = YOLO(f"src/models/{pieces_name}")
        self.piece_detector.to('cpu' if not GPU.is_available() else 'cuda')
        self.image: np.ndarray = None
        self.homography: np.ndarray = None

    #Sets target image after reszing to 1280x1280

    def set_image(self, image):
        self.image = cv2.resize(image, (1280, 1280))

    #Runs the piece detection with the set confidence level; change as you'd like but 0.25 has worked well for me
    #Takes keyword argument 'save' to save the detection into the file 'piece_detection.jpg'

    def run_piece_detection(self, confidence, **kwargs):
        result = self.piece_detector.predict(self.image, conf=confidence, verbose=False)
        if kwargs.get('save'): result[0].save("tests/yolo_output.jpg")
        render_image = self.image.copy()
        if kwargs.get('save'):
            for box, _ in zip(result[0].boxes.xyxy.cpu().numpy(),
                                        result[0].boxes.cls.cpu().numpy().astype(int)):
                x1, y1, x2, y2 = map(int, box)
                cv2.rectangle(render_image, (x1, y1), (x2, y2), (0, 255, 0), 2)

            cv2.imwrite("tests/piece_detection.jpg", render_image)
        
        return result[0].boxes.xyxy.cpu().numpy(), result[0].boxes.cls.tolist()

    #Computes homography matrix and warped image based on finding the 3x7 set of corners that are visible on any intial board
    #findChessboardCorners() fails if any pieces are in the center (error is thrown in this case)
    #Associates 3x7 corners to their corresponding locations in the 1280x1280 warped image
    #Computes homography using findHomography() and warps image, returning both so that they can be used by find_board

    def find_corners_perspective_transform(self):
        width, height = 3, 7
        pattern_size = (width, height) # in format width, height
        ret, corners = cv2.findChessboardCorners(self.image, pattern_size)
        if not ret: raise ValueError('findChessboardCorners() failed on the given image because the center block of 4x8 squares was occupied by pieces')
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
        corners = cv2.cornerSubPix(cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY), corners, (5, 5), (-1, -1), criteria)

        def reorder_corners(corners):
            cols, rows = pattern_size
            pts = corners.squeeze()
            grid = pts.reshape((rows, cols, 2))
            dx = np.ptp(grid[0, :, 0])
            dy = np.ptp(grid[:, 0, 1])
            if dx > dy:
                grid = grid.transpose((1, 0, 2))
            if grid[0, 0, 1] > grid[-1, 0, 1]:
                grid = grid[::-1, :, :]
            if grid[0, 0, 0] > grid[0, -1, 0]:
                grid = grid[:, ::-1, :]
            return grid.reshape(-1, 2).astype(np.float32)
        
        og_x, og_y = 480, 160
        og_corners = reorder_corners(corners)
        final_corners = [[x,y] for y in range(og_y, og_y + 160*height, 160) for x in range(og_x, og_x + 160*width, 160)]
        final_corners = np.float32(final_corners)
        self.homography, _ = cv2.findHomography(og_corners, final_corners, cv2.RANSAC)
        return cv2.warpPerspective(self.image, self.homography, self.image.shape[:2][::-1])    

    #Locates pieces on the board
    #Supports optional arg 'save' to save prediction from pipeline in the warped image space
    #Supports optional arg 'table' to generate table which can and should be displayed in the developer frontend
    #Supports optional arg 'board_num' to include board number in table for developer frontend
    #Implements Maximum piece square association as described in the paper
    #Takes arguments warped_frame (the transformed image), boxes (bounding boxes generated by YOLO), and classes (piece identifications from YOLO)

    def find_board(self, warped_frame, boxes, classes, **kwargs):
        corner_points = [(x, y) for y in range(0, self.image.shape[0] + 1, self.image.shape[0]//8) for x in range(0, self.image.shape[1] + 1, self.image.shape[1]//8)]
        board = [[Square(corner_points[base:=i * 9 + j], corner_points[base+1], corner_points[base+9], corner_points[base+10]) for j in range(0, 8)] for i in range(0, 8)]
        large_piece_set = {1, 4, 7, 10}
        if kwargs.get('save'):
            for x, y in corner_points: cv2.circle(warped_frame, (x, y), 3, (0, 255, 0), 3, cv2.LINE_AA, 0)
        formatted_output = dict() if kwargs.get('table') else None
        area_thresh = 160**2/16

        for name, (x1, y1, x2, y2) in zip(classes, boxes):
            xtl, ytl = x1, int(y1 + (0.9 if name in large_piece_set else 0.8)*(y2-y1))
            xtr, ytr = x2, ytl
            xbr, ybr = x2, y2
            xbl, ybl = x1, y2
            box_poly = np.float32([[xtl, ytl], [xtr, ytr], [xbr, ybr], [xbl, ybl]])
            max_area, max_square, square_num, max_poly = 0, None, -1, None
            for i, row in enumerate(board):
                for j, square in enumerate(row):
                    inter_area, inter_poly = square.get_intersect_area(box_poly, self.homography)
                    max_square = square if inter_area > max_area else max_square
                    square_num = i*8+j if inter_area > max_area else square_num
                    max_poly = inter_poly if inter_area > max_area else max_poly
                    max_area = inter_area if inter_area > max_area else max_area
            if max_area > area_thresh: 
                max_square.set_piece(name)
                if kwargs.get('table'):
                    piece = max_square.get_piece()
                    curr_output = dict()
                    curr_output['Board No.'] = kwargs.get('board_num') if kwargs.get('board_num') is not None else 'None'
                    curr_output['Piece'] = piece.unicode_symbol()
                    curr_output['Color'] = 'W' if piece.color else 'B'
                    curr_output['Bounding Box'] = (int(x1), int(y1), int(x2), int(y2))
                    formatted_output[max_square] = curr_output
                if kwargs.get('save'): cv2.fillConvexPoly(warped_frame, np.int32(cv2.perspectiveTransform(np.float32([box_poly]), self.homography)), (255, 0, 0))
        if kwargs.get('save'): cv2.imwrite('tests/mask_prediction.jpg', warped_frame)
        return board if not kwargs.get('table') else (board, formatted_output)

    #Prints board in console given 8x8 matrix for board as input

    def print_board(self, board):
        for row in board:
            for i, square in enumerate(row):
                if square.get_piece() is not None:
                    print(square.get_piece().symbol(), end="  " if i<7 else "\n")
                else:
                    print(".", end="  " if i<7 else "\n")
    
    #Returns correct orientation of the board given the board as input
    #Currently assumes side angle, so just takes the side with more white pieces and orients that way.

    def get_rotation(self, board: list[list[Square]]):
        white_pieces, black_pieces = 0, 0
        for row in board:
            for i, square in enumerate(row):
                if square.get_piece() is not None:
                    piece_color = square.get_piece().color
                    white_pieces += (i >= 4) if piece_color else 0
                    black_pieces += (i >= 4) if not piece_color else 0
        return np.rot90(board, k=-1) if white_pieces >= black_pieces else np.rot90(board, k=1)

    #Creates svg file to view the board in a pretty manner
    #Accepts keyword argument save to save the image as a svg file
    #Accepts keyword argument table to generate table of results

    def make_pychess_board(self, board, **kwargs):
        chess_board = chess.Board(None)
        letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
        nums = ['8', '7', '6', '5', '4', '3', '2', '1']
        table_list = []
        if kwargs.get('table') and not kwargs.get('formatted_output'):
            raise ValueError('Please provide formatted output from find_board if you are providing keyword argument "table" as True')
        formatted_output = None if not kwargs.get('table') else kwargs.get('formatted_output')
        for r, row in enumerate(board):
            for c, square in enumerate(row):
                chess_board.set_piece_at(chess.parse_square((loc:=letters[c] + nums[r])), square.get_piece())
                if kwargs.get('table') and square in formatted_output:
                    curr_output = formatted_output[square]
                    curr_output['Square'] = loc
                    table_list.append(curr_output)
        if kwargs.get('save'):
            board_svg = chess.svg.board(board=chess_board)
            with open('board.svg', 'w') as file:
                file.write(board_svg)
        return chess_board if not kwargs.get('table') else (chess_board, tabulate(table_list, headers = 'keys'))
#EOF